<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[git commit 합치기 (rebase -i)]]></title>
      <url>/git/2018/11/08/git-commit-%ED%95%A9%EC%B9%98%EA%B8%B0/</url>
      <content type="text"><![CDATA[상황회사에서 기능을 구현하고 풀리퀘까지 보낸 상황에서 로직에 수정해야하는 부분을 발견했다.로직을 수정하고 커밋하려고 하니 지저분한 커밋이 늘어나는 것 같아 굉장히 찝찝해졌다. ‘이건 커밋 메세지를 또 뭐라하지..’어떻게 하면 좋을 까 생각해보니 예전에 사수님께서 커밋을 합칠 수 있다고 말씀해주신 것이 생각나 바로 검색을 해보았다.커밋 합치기깃을 사용하는 사람이라면 같은 기능 구현에 대한 여러 번의 커밋을 한적이 있을 것이다.웹 디자인 css를 완성하고 '웹 디자인 구현'이라고 커밋을 했는데 웹 페이지를 다시 보니 폰트 사이즈가 맘에 안들어서 수정한 후 '폰트 사이즈 수정' 이라고 커밋을 했다.커밋 후 다시 보니 이번에는 폰트 색깔이 맘에 안들어 바꾸고 '폰트 색깔 수정' 이라고 커밋을 했다.디자인을 구현한건 똑같은데 여러 번의 커밋이 이루어졌다.이렇게 되면 협업을 할 때 다른사람이 커밋의 내용에 대해 의문이 들 수도 있고 이런 커밋들이 많아지면 커밋 이력은 매우 지저분해진다.이럴 때 커밋을 합치면 이런 문제를 해결할 수 있다.커밋을 합치는 것은 rebase -i 명령어로 합칠 수 있다.먼저 git log를 통해 내가 어디서부터 어디까지 커밋을 합칠 것인지 살펴보자.commit e1f09108a51c09919c3488f06e3160c8f57Author: Date:   Thu Nov 8 15:06:01 2018 +0900    Message 4commit 405715479d9e97bbe714820dda88e04dbcAuthor: Date:   Thu Oct 25 12:14:21 2018 +0900    Message 3Message 3 커밋에  Message 4 커밋을 합쳐보도록 하겠다.$ git rebase -i HEAD~2 위 명령어는 최근 커밋 2개를 합치라는 명령어이다.head는 현재 브랜치에서 마지막 커밋을 가르킨다.즉 마지막 커밋과 그 전 커밋을 합치는 것이다.만약 2개 커밋이 아닌 3개 커밋을 합치고 싶다면 HEAD~3 이라고 숫자만 바꿔주면 된다.위 명령어를 실행하면 vi 편집기가 뜰 것이다.pick 4057154 Message 3pick e1f0910 Message 4vi 상단에는 내가 합치고 싶은 커밋들이 나와있을 건데 여기서 합치고 싶은 커밋의 pick을 squash로 바꿔준다.pick 4057154 Message 3squash e1f0910 Message 4message 4 커밋을 message 3 커밋으로 합칠 거기 때문에 Message 4의 pick을 squash로 바꿔준다.:wq 저장을 하면# This is a combination of 2 commits.# This is the 1st commit message:Message 3# This is the commit message #2:# Message 4# Please enter the commit message for your changes. Lines starting이렇게 다시 vi 편집기가 뜨는데 여기서는 어떤 커밋 메세지를 사용할 것이냐를 묻는 것이므로Message 4 커밋 메세지를 지우면 message 3의 커밋 메세지만 남게 된다.지우지 않고 위와 같이 주석 처리를 할 수 있다.위 설정까지 다 했다면 커밋이 합쳐졌을 것이다.commit 405715479d9e97bbe714820dda88e04dbc493282Author: Date:   Thu Oct 25 12:14:21 2018 +0900    Message 3커밋 합친 것을 원격 저장소에도 반영하고 싶으면 push를 하면 된다.$ git push -f origin [branch]커밋 합치기 참 쉽죵? 🤗]]></content>
      <categories>
        
          <category> git </category>
        
      </categories>
      <tags>
        
          <tag> git rebase </tag>
        
          <tag> git commit 합치기 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Docker]]></title>
      <url>/til/2018/11/06/TIL-Docker/</url>
      <content type="text"><![CDATA[도커란?  컨테이너 기반의 오픈소스 가상화 플랫폼컨테이너격리된 공간에서 프로세스가 동작하는 기술 (가상화 기술)이미지를 실행한 상태.이미지컨테이너 실행에 필요한 파일과 설정 값등을 포함하고 있는 것.상태 값을 가지지 않고 변하지 않음.  이미지가 클래스이면 컨테이너는 클래스의 인스턴스이다.같은 이미지에서 여러 개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 삭제되더라도 이미지는 변하지 않고 그대로 남아있음.  하나의 서버에 여러개의 컨테이너를 실행하면 서로 영향을 미치지 않고 독립적으로 실행되어 마치 가벼운 VMVirtual Machine을 사용하는 느낌을 줍니다. 실행중인 컨테이너에 접속하여 명령어를 입력할 수 있고 apt-get이나 yum으로 패키지를 설치할 수 있으며 사용자도 추가하고 여러개의 프로세스를 백그라운드로 실행할 수도 있습니다. CPU나 메모리 사용량을 제한할 수 있고 호스트의 특정 포트와 연결하거나 호스트의 특정 디렉토리를 내부 디렉토리인 것처럼 사용할 수도 있습니다.정말 가벼운 VM 사용하는 것 같음! 짱Mac에서 도커 설치Docker-for-Mac 이 곳에서 로그인 후 설치!설치가 완료되었다면 도커가 잘 설치되었는지 확인해보자.$ docker versionClient: Version:           18.06.1-ce API version:       1.38 Go version:        go1.10.3 Git commit:        e68fc7a Built:             Tue Aug 21 17:21:31 2018 OS/Arch:           darwin/amd64 Experimental:      falseServer: Engine:  Version:          18.06.1-ce  API version:      1.38 (minimum version 1.12)  Go version:       go1.10.3  Git commit:       e68fc7a  Built:            Tue Aug 21 17:29:02 2018  OS/Arch:          linux/amd64  Experimental:     true명령어컨테이너 실행$ docker run ubuntu:16.04run ubuntu 이미지가 있으면 docker 컨테이너 실행, 없으면 이미지 다운로드하고 컨테이너 실행 후 바로 종료됨.$ docker run -rm -it ubuntu:16.04 /bin/bash-rm 컨테이너 실행 후 종료시 컨테이너 삭제 옵션-it  키보드 입력을 위한 옵션$ docker run -d -p 1234:6379 redis# 아래와 같이 접속$ telnet localhost 1234-d 백그라운드 작업-p 컨테이너 포트를 호스트 포트로 연결$ docker run -d -p 3306:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=true --name mysql mysql:5.7-e 환경변수 설정--name 컨테이너 이름 설정컨테이너 목록 확인$ docker ps # 실행 중인 컨테이너 목록$ docker ps -a # 전체 컨테이너 목록실행 중인 컨테이너 중지$ docker stop ${container_id or container_name}컨테이너 완전 삭제$ docker stop ${container_id or container_name}이미지 목록 확인$ docker images이미지 업데이트$ docker pull ubuntu:14.04 pull  이미지를 최신 버전으로 다시 다운 받을 수 있음.이미지 삭제$ docker rmi ${image_id}컨테이너가 실행 중인 이미지는 삭제되지 않음!컨테이너 실행 로그 확인$ docker logs ${container_id or container_name}컨테이너에서 실행한 로그를 확인.$ docker logs --tail 10 ${container_id or container_name}--tail컨테이너에서 실행한 로그 마지막 10줄까지 출력.$ docker logs -f ${container_id or container_name}-f실시간으로 로그가 생성되는 것을 확인함.컨테이너 명령어 실행$ docker exec -it mysql /bin/bash # 컨테이너에 접속$ mysql -uroot 컨테이너에 들어가 보거나 컨테이너의 파일을 실행하고 싶을 때.run 새로 컨테이너를 만들어서 실행.exec 실행 중인 컨테이너에 명령어를 내림.접속한 이후에는 어떤 작업도 할 수 있고 컨테이너를 마음껏 조작 할 수 있음.그 외컨테이너를 삭제한다는 것  컨테이너에서 생성된 파일이 사라지는 것  데이터베이스의 데이터가 사라지는 것  웹 애플리케이션의 사용자가 올린 이미지가 사라지는 것컨테이너 삭제시 유지해야하는 데이터는 반드시 컨테이너 내부가 아닌 외부 스토리지에 저장해야함.Docker compose설정 파일을 이용한 도커 설정version: '2'services:   db:     image: mysql:5.7     volumes:       - db_data:/var/lib/mysql     restart: always     environment:       MYSQL_ROOT_PASSWORD: wordpress       MYSQL_DATABASE: wordpress       MYSQL_USER: wordpress       MYSQL_PASSWORD: wordpress   wordpress:     depends_on:       - db     image: wordpress:latest     volumes:       - wp_data:/var/www/html     ports:       - "8000:80"     restart: always     environment:       WORDPRESS_DB_HOST: db:3306       WORDPRESS_DB_PASSWORD: wordpressvolumes:    db_data:    wp_data:referhttps://subicura.com/2017/01/19/docker-guide-for-beginners-2.html]]></content>
      <categories>
        
          <category> TIL </category>
        
      </categories>
      <tags>
        
          <tag> docker </tag>
        
          <tag> docker 사용법 </tag>
        
          <tag> docker 명령어 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[레드햇 페도라에서 Nginx 설치하기]]></title>
      <url>/nginx/2018/11/05/%EB%A0%88%EB%93%9C%ED%96%87-%ED%8E%98%EB%8F%84%EB%9D%BC%EC%97%90%EC%84%9C-Nginx-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/</url>
      <content type="text"><![CDATA[레드햇 페도라에서 Nginx 웹 서버를 설치한다. centos OS에서도 똑같이 설치할 수 있다.먼저 nginx를 받을 repository를 추가한다.$ vi /etc/yum.repos.d/nginx.repo[nginx]name=nginx repobaseurl=http://nginx.org/packages/[OS]/[OSRELEASE]/$basearch/gpgcheck=0enabled=1여기서 대괄호로 감싸진 OS와 OSRELEASE를 자신의 OS와 버전에 따라 변경을 해줘야 한다.http://nginx.org/packages/ 여기에 있는 자신의 OS와 OS 버전에 맞는 것이 있는지 확인 후 변경을 해준다. (없으면 패키지 설치가 안 되기 때문에 꼭 확인하고 변경해주자)설정 후 저장을 하고 Nginx를 설치한다.$ yum install nginxNginx 명령어      Nginx 시작    $ sudo service nginx start        Nginx 중지    $ sudo service nginx stop        Nginx 재시작    $ sudo service nginx restart        Nginx 상태    $ sudo service nginx status        Nginx 설정 후 다시 로드    $ sudo service nginx reload        Nginx 설정이 성공 적인지 확인    $ sudo nginx -t  referCentOS 7 Nginx 설치하기]]></content>
      <categories>
        
          <category> Nginx </category>
        
      </categories>
      <tags>
        
          <tag> nginx 설치 </tag>
        
          <tag> fedora nginx 설치 </tag>
        
          <tag> 레드햇 페도라 nginx 설치 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[AWS(rhel fedora)Nginx-uWSGI-Django 연동하기]]></title>
      <url>/django/2018/11/05/Nginx-uWSGI-Django/</url>
      <content type="text"><![CDATA[이 포스팅에서는 AWS에서 서버를 셋팅할 것이기 때문에 AWS EC2 설정이 되어있다는 가정하에 진행한다.또한 글쓴이의 OS 환경은 레드햇 페도라 환경에서 진행했다.먼저 간단하게 서버 구조를 말하면  Nginx 80번 포트로 접속하면 uWSGI 8000번 포트로 요청을 보내 우리가 만든 Django 프로젝트에 접속하게 될 것이다.우리가 사용자에게 listen할 포트(80)는 열어놔야하기 때문에 AWS 사용자 지정 포트에서 80번 포트를 열어줘야한다.포트를 변경하고 싶으면 변경해도 되지만 설정한 포트에따라 사용자 지정 포트를 열어줘야 하는 것도 명심하자.1. Djangodjango 프로젝트는 배포될 준비가 다 되어있다는 가정 하에 진행한다.      가상환경 셋팅    static root 설정  media root 설정  $ python manage.py collectstatic2.Nginx글쓴이는 Nginx 설정에 정말 삽질을 했다.블로그를 보며 배포를 하려고 하는데 블로그에서는 sites-available 폴더에 conf 파일을 넣으면 된다고하는데.. 해당 폴더가없어서 삽질을 엄청했다.이 포스팅은 sites-available, sites-enabled 폴더가 없는 개발자들에게 유용한 포스트가 될 것이다.(그러길 바란다..)먼저 uWSGI와 nginx 서버 등을 설정하기 위해 conf 파일을 생성한다.etc/nginx/conf.d/testprj.conf 생성 (nginx의 경로는 OS 별로 다를 수  있기 때문에 꼭 확인해보자.)[..] 대괄호 안에있는 것은 자신의 프로젝트의 이름이나 경로에 따라 알맞게 변경한다.# etc/nginx/conf.d/testprj.conf server {    listen                   80; # nginx가 listen할 포트    server_name              [www.your.domain.com 123.23.56.5] #서버 도메인이나 아이피 입력    client_max_body_size     10M;    access_log               /var/log/testprj.access.log; # 성공 로그를 기록할 파일    error_log                /var/log/testprj.error.log; # 에러 로그를 기록할 파일     # -------------    # Handle Django    # -------------    location / {    	# 외부에서 특정 포트로 Nginx를 통해 http 요청을 받았을 때 요청을 uWSGI를 통해 Django로 넘김        proxy_pass       http://localhost:8000; # uWSGI가 nginx 요청을 받을 주소와 포트        proxy_set_header Upgrade            $http_upgrade;        proxy_set_header Connection         "upgrade";        proxy_set_header Host               $host;        proxy_set_header X-Real-IP          $remote_addr;        proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto  $scheme;    }    # ------------------    # serve static files    # ------------------    # here we assume the STATIC_ROOT inside your django project is    # set to /static/    location /static/ {    	# /static/ 으로 들어 올 때 경로 설정.        alias   [/home/user/testprj/static/]; # django project settings.py에 설정되어있는 STATIC_ROOT 주소    }}여기서$ sudo nginx -tnginx: [emerg] could not build server_names_hash, you should increase server_names_hash_bucket_size: 64nginx: configuration file /etc/nginx/nginx.conf test failednginx 서버 확인 시 이런 오류가 난다면nginx.conf 파일 수정을 해줘야 한다.아래 설정을 http {} block에 설정 안에 넣는다.# etc/nginx/nginx.confhtttp{    server_names_hash_bucket_size 512;	server_names_hash_max_size 512;	...}오류에는 64라고 되어있어 64로 했더니 오류가 사라지지 않아  512로하니까 되었다.이렇게 하고 $ sudo nginx -t 수행 -&gt; 성공하면 nginx 설정 끝!3. uWSGI가상환경이 활성화된 상태에서 uWSGI 설치$ pip install uwsgi잘 깔렸는지 확인해보자$ wsgi --http :8000 --module [your-project-name].wsgi (manage.py 디렉토리에서)잘 되면 ini파일 생성$ sudo vi [testprj].ini# home/user/testprj/[testprj].ini[uwsgi] # 이건 변경 Xßmodule          =  [testprj].wsgi:applicationmaster          =  truepidfile         =  [testprj].uwsgi.pidenable-threads  = truehttp            =  127.0.0.1:8000 # uWSGI 포트 설정 processes       =  5harakiri        =  50max-requests    =  5000# clear environment on exitvacuum          =  true# optional path to a virtualenvhome            =  [/home/user/.pyenv/versions/3.6.5/envs/devenv] # 가상환경 경로 설정# background the processdaemonize       =  [testprj].uwsgi.log이렇게 하구 저장!  실행 $ uwsgi testprj.ini (가상환경 안에서 )  uWSGI 로그확인 $ vi testprj.uwsgi.log  uWSGI 중지 $ uwsgi --stop [testprj].uwsgi.piduWSGI 가 실행된 상태에서 nginx 서버를 시작한다.$ sudo service nginx start이후 맨 처음 nginx에서 생성한 conf 파일의 server_name에 설정한 주소(AWS 주소)로 들어가보면 Django project가 띄어져 있을 것이다! 그러면 연동 끝!설정 중 오류가 있으면 댓글 남겨주세요 💁‍referhttps://medium.com/@charlesthk/deploy-nginx-django-uwsgi-on-aws-ec2-amazon-linux-517a683163c6https://www.savour-it.com/posts/2018-02-06-nginx-uwsgi-django-setting/https://www.digitalocean.com/community/tutorials/how-to-serve-django-applications-with-uwsgi-and-nginx-on-ubuntu-14-04https://blog.leop0ld.org/posts/use-python3-django-uwsgi-nginx/http://charles.lescampeurs.org/2008/11/14/fix-nginx-increase-server_names_hash_bucket_size]]></content>
      <categories>
        
          <category> django </category>
        
      </categories>
      <tags>
        
          <tag> django </tag>
        
          <tag> nginx uwsgi django 연동 </tag>
        
          <tag> nginx uwsgi django </tag>
        
          <tag> aws nginx django </tag>
        
          <tag> aws django 배포 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Django-MySQL 연동하기]]></title>
      <url>/django/2018/11/05/Django-MySQL-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0/</url>
      <content type="text"><![CDATA[이 포스팅은 mac과 linux 환경에서의 Django-MySQL 연동 글이다.윈도우 환경에서 작업을 진행한다면, 이 포스팅 과 함께 보기 추천한다. (별로 다른 건 없지만 윈도우 환경에서 오류 해결 법이 좀 더 추가되어있다)MySQL이 설치되어있다는 가정하에 진행하므로 꼭 설치 후 아래 항목들을 차례로 진행하길 바란다. (설치가 되어있지 않으면 오류가 난다)Django와 MySQL을 연동하기 위한 연동 드라이버를 설치django에서 제공하는 MySQL 연동 드라이버 모듈은 3가지가 있다.  MySQLdb - 제일 안정된 드라이버, python3은 지원하지 않음  Mysqlclient - MySQLdb를 개선한 패키지, Python3.3 이상의 버전도 지원하고있음, 장고에서 추천함  MySQL Connector/Python - MySQL 개발사 오라클에서 제공하는 드라이버위 모듈 중 자신에게 맞는 드라이버를 설치하면 되는데 우리는 mysqlclient를 사용할 것이다.mysqlclient를 설치해준다.$ pip sintall mysqlclientcentos/rhel fedora OS에서 설치시mysqlclient OSError: mysql_config not found이런 오류가 발생한다면 mysql-devel을 설치해주면 해결된다.$ sudo yum install mysql-develDjango에서 MySQL 연동 세팅정상적으로 설치가 되었다면 django project의 settings.py 파일에서 DATABASE 항목을 설정해준다.# settings.pyDATABASES = {	'default': {		'ENGINE':'django.db.backends.mysql', # mysql 엔진 설정		'NAME':'mysite', # 데이터베이스 이름 		'USER':'root', # 데이터베이스 연결시 사용할 유저 이름		'PASSWORD':'password',# 유저 패스워드        'HOST':'l27.0.0.1', # 데이터베이스 서버 주소        'PORT':'3306' # 데이터베이스 서버 포트    }}ENGINE을 제외한 항목은 자신의 mysql 설정에 맞게 수정해야한다.지금까지 설정이 올바르게 되었다면 Django와 MySQL이 연동이 되었을 것이다.MySQL의 데이터(테이블)를 반영만약 현재 MySQL의 데이터베이스에 저장되어있는 테이블들을 Django project에 반영하고 싶다면$ python manage.py inspectdb &gt; ./app/models.py명령어를 사용하면 된다.mysql&gt; desc board_tbl;+---------+--------------+------+-----+---------+----------------+| Field   | Type         | Null | Key | Default | Extra          |+---------+--------------+------+-----+---------+----------------+| idx     | int(6)       | NO   | PRI | NULL    | auto_increment || writer  | int(11)      | YES  |     | NULL    |                || subject | varchar(255) | YES  |     | NULL    |                || content | text         | YES  |     | NULL    |                || date    | datetime     | YES  |     | NULL    |                |+---------+--------------+------+-----+---------+----------------+MySQL 테이블이 model로 적용된 모습# app/models.py...class BoardTbl(models.Model):    idx = models.AutoField(primary_key=True)    writer = models.IntegerField(blank=True, null=True)    subject = models.CharField(max_length=255, blank=True, null=True)    content = models.TextField(blank=True, null=True)    date = models.DateTimeField(blank=True, null=True)    class Meta:        managed = False        db_table = 'board_tbl'Django migration을 MySQL에 반영Django의 migration을 MySQL에 반영하는 것은 sqllite3에 migration을 반영하는 것과 같다. $ python manage.py migrate이 명령어를 실행하게 되면 MySQL 테이블에 auth_user 등 장고의 기본 테이블들이 생성된 것을 확인할 수  있을 것이다.이렇게 마지막까지 잘 되었다면 MySQL을 사용할 준비를 마친 것이다.이제 ORM, raw SQL 등을 기존 sqlite3 처럼 사용할 수 있다.]]></content>
      <categories>
        
          <category> django </category>
        
      </categories>
      <tags>
        
          <tag> django mysql연동 </tag>
        
          <tag> django mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[GIL을 알아보자]]></title>
      <url>/python/2018/10/24/GIL/</url>
      <content type="text"><![CDATA[Global Interpreter Lock한  CPU만 일함.!다중 CPU 환경에서 동시에 여러 파이썬 코드를 병렬로 실행할 수 없음.  인터프리터의 구현이 쉬워짐  Garbage Collector 만들기 조음  C/C++ 확장 만들기 만들기 쉬움.프로그램에 I/O 작업을 많이하면 파이썬 쓰레드도 좋음.우리가 하는 일반 프로그래밍은 I/O Bound계산을 많이 하는 작업쓰레드 -&gt; 프로세스다중 CPU에서 병렬 실행을 위해서는 다중 프로세스를 이용하는 multiprocessing 모듈을 사용함.프로그램에 I/O 작업을 많이하면 파이썬 쓰레드도 좋음.우리가 하는 일반 프로그래밍은 I/O Bound계산을 많이 하는 작업쓰레드 -&gt; 프로세스다중 CPU에서 병렬 실행을 위해서는 다중 프로세스를 이용하는 multiprocessing 모듈을 사용함.th1 = Thread(target=do_work)th1.start()th1.join()pr1 = Process(target=do_work)pr1.start()pr1.join()Process운영체제가 작업하는 단위Thread이 Process 안에서 공유되는 메모리를 바탕으로여러 작업을 생성하는 작업 단위.-&gt; 각 thread마다 할단된 개인적인 메모리가 있으면서 thread가 속한 process가 가지는 메모리에도접근가능함.Race condition여러 thread가 공유된 데이터를 변경함으로써 발생하는 문제.“Thread-safe 하다”thread들이 race condition을 발생시키지 않으면서 각자의 일을 수행한다는 뜻.Mutex  Thread-safe한 코드를 만들기 위해서 사용하는 것 중 하나.  Race condition을 막기 위해 공유되는 메모리의 데이터를 여러 thread가 동시에 사용할 수 없도록 잠그는일을 맡음.휴대폰이 없던 시절에는 공중 전화를 주로 이용했었다. 거리의 모든 남자들은 각자의 아내에게 전화를 너무나 걸고 싶어한다.어떤 한 남자가 처음으로 공중 전화 부스에 들어가서 그의 사랑하는 아내에게 전화를 걸었다면, 그는 꼭 전화 부스의 문을 꼭 잡고 있어야 한다. 왜냐하면 사랑에 눈이 먼 다른 남자들이 전화를 걸기 위해 시도때도 없이 달려들고 있기 때문이다. 줄 서는 질서 문화 따위는 없다. 심지어 그 문을 놓친다면, 전화 부스에 들이닥친 남자들이 수화기를 뺏어 당신의 아내에게 애정 표현을 할 지도 모른다.아내와의 즐거운 통화를 무사히 마쳤다면, 이제 문을 잡고 있던 손을 놓고 부스 밖으로 나가면 된다. 그러면 공중 전화를 쓰기 위해 달려드는 다른 남자들 중 제일 빠른 한 명이 부스에 들어가서 똑같이 문을 꼭 잡고 그의 아내와 통화할 수 있다.  thread: 각 남자들  mutex: 공중 전화 부스의 문  lock: 그 문을 잡고 있는 남자의 손  resource: 공중 전화CPython reference counting 을 하는 과정에서Rece condition이 일어나면 그 결과는 메모리 유실/object가 죽음이 발생이를 해결하기 위해 mutex사용 -&gt; object 하나하나 마다 대응하는 mutex가 필요함! 성능적으로 많은 손해, deadlock 위험상황CPython의 결정mutex를 통해 모든 reference 개수를 일일히 보호하지 말고 python interpreter자체를 잠구자!-&gt; 오직 한 thread만이 python 코드를 사용할 수 있음한 프로세스 안에서 여러 쓰레드를 이용한 병렬처리를 막음.한 쓰레드가 파이썬코드를 실행하기 위해선 공중전화 박스에 들어가 interpreter lock을 잡아야함!그래서 Global Interpreter Lock]]></content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
          <tag> python gil </tag>
        
          <tag> gil </tag>
        
          <tag> global interpreter block </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[heroku를 사용해 django 프로젝트 배포하기]]></title>
      <url>/django/2018/10/24/Django-heroku-deploy/</url>
      <content type="text"><![CDATA[git이 설치되어있다고 가정한다.1. heroku 회원가입2. 헤로쿠 사용을 위한 패키지 다운virtualenv 활성화 상태에서 패키지 다운로드$ pip install dj-database-url gunicorn whitenoise3. requirements.txt 파일 생성$ pip freeze &gt; requirements.txt생성된 requirements.txt 맨 아래에 아래 내용 추가$ psycopg2==2.7.14. Procfile 파일 생성헤로쿠에게 웹 사이트를 시작시키기 위해 실행되어야할 명령어의 순서를 알려주기 위해 procfile 파일 생성 (확장자 x, cmd에서 vi나 nano로 생성)web: gunicorn &lt;mysite&gt;.wsgi --log-file -웹 애플리케이션을 배포할 때 gunicorn &lt;mysite&gt;.wsgi 명령을 실행하는 것을 의미(gunicorn은 강력한 버전의 runserver 명령어)5. runtime.txt 파일 생성헤로쿠에게 어떤 버전의 파이썬을 사용하는지 알려줌.# djangoproject/runtime.txtpython-3.6.5 # 프로젝트 파이썬 버전5. settings.py 설정로컬 컴퓨터 설정 파일 local_settigns.py생성# local_settings.pyimport osBASE_DIR = os.path.dirname(os.path.dirname(__file__))DATABASES = {    'default': {        'ENGINE': 'django.db.backends.sqlite3',        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),    }}DEBUG = True이 파일은 로컬에서 프로젝트를 돌릴 때 사용을 하기 위함인 것 같다.6. 헤로쿠 배포를 위한 settings.py 설정# settings.pyimport dj_database_url...DEBUG = FalseALLOWED_HOSTS = ['127.0.0.1', '.herokuapp.com']...DATABASES = {    'default': {        'ENGINE': 'django.db.backends.postgresql_psycopg2',        'NAME': 'lowell',        'USER': 'name',        'PASSWORD': '',        'HOST': 'localhost',        'PORT': '',    }}...db_from_env = dj_database_url.config(conn_max_age=500)DATABASES['default'].update(db_from_env)7. wsgi.py 설정프로젝트의 wsgi.py 파일의 끝에 다음 라인 추가# wsgi.py...from whitenoise.django import DjangoWhiteNoiseapplication = DjangoWhiteNoise(application)8. gitignore 파일 생성*.pycdb.sqlite3myvenv__pycache__local_settings.py # 로컬 환경을 위한 파일이기 때문에 등록9. heroku 로그인아까 만들었던 계정으로 로긘하깅$ heroku login10. git 저장소 생성,커밋현재 장고 프로젝트 루트 디렉토리에 git 저장소를 생성부터 커밋$ git init$ git add . $ git status $ git commit -m "additional files and changes for Heroku"11. 애플리케이션 이름 설정$ heroku create &lt;appname&gt;이 이름은 도메인이 된다. &lt;appname&gt;.herokuapp.com12. 이제 배포하면 된다.$ git push heroku master13. 애플리케이션 접속헤로쿠에 웹 프로세스를 시작하라고 말한다.$ heroku ps:scale web=1앱에 들어가보장. 아래 명령어를 입력하면 브라우저가 뜰 것이당.$ heroku open14. migrate , createsuperuser$ heroku run python manage.py migrate$ heroku run python manage.py createsuperuser오류 발생시오류가 생겼다면 다음 블로그를 참조해보자.오류해결referhttps://tutorial-extensions.djangogirls.org/ko/heroku/http://ggilrong.tistory.com/entry/heroku%EC%97%90-django-%EC%95%B1%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0http://morningbird.tistory.com/23]]></content>
      <categories>
        
          <category> django </category>
        
      </categories>
      <tags>
        
          <tag> django </tag>
        
          <tag> django 배포 </tag>
        
          <tag> django heroku </tag>
        
          <tag> heroku </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[python3 venv 가상환경 사용하기]]></title>
      <url>/python/2018/08/23/python3-venv-%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</url>
      <content type="text"><![CDATA[venv는 python3에서 기본으로 제공하는 가상환경(virtualenv)을 만들 수 있는 라이브러리이다.나는 이 라이브러리를 여태동안 모르고 있었다!원래 mac에서는 pyenv를 사용하여 가상환경을 세팅했는데 윈도우는pyenv를 사용할 수 없다.그래서 그동안 서드파티 라이브러리인 virtualenv를 사용하고 있었는데 venv로 갈아탈 예정이다.기본으로 제공하는데 사용해줘야지!만약 virtualenv 라이브러리를 사용하고 싶다면 해당 포스트에서 사용법을 확인하면 된다.venv 사용하기먼저 venv는 python3에 빌트인 되어있기 때문에 설치를 하지 않아도 사용가능하고 python2.7에서는 사용이 불가능하다.python2를 사용한다면 virtualenv/pyenv 라이브러리를 설치해야한다.      가상환경 생성    # window # python -m venv [venv 이름]&gt; python -m venv ./myenv   # mac# python3 -m venv [venv이름]$ python3 -m venv ./myenv            가상환경 활성화    # window&gt; myenv\Scripts\activate# mac$ source myenv\bin\activate # or . myenv\bin\activate        가상환경에 성공적으로 들어간다면 prompt 앞에 현재 가상환경이 표시될 것이다.    지금부터는 격리된 환경에서 작업이 가능하다!    (myenv) $ &gt;        가상환경 비활성화    &gt; deactivate      ]]></content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
          <tag> python virtualenv </tag>
        
          <tag> python venv </tag>
        
          <tag> python pyenv </tag>
        
          <tag> window pyenv </tag>
        
          <tag> python 가상환경 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
