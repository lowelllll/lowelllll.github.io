---
title: Virtual Momery 
description: 181202 Today I learned Virtual Memory
categories:
 - TIL
tags: [virtual memory, 가상 메모리]
---

`TIL 카테고리의 글은 그날 배운 것을 정리하는 목적으로 포스팅합니다. 내용이 잘못되었다면 댓글로 피드백 부탁드립니다.`

# 가상 메모리

> `Virtual Memory` 한정된 물리 메모리의 한계를 극복하고자 디스크와 같은 저장장치를 활용해 애플리케이션들이 더 많은 메모리를 활용할 수 있게 해주는 것

- 어떤 프로세스를 실행할 때 프로세스 전체가 메모리에 적재되지 않고도 실행이 가능 하도록 함.
- 현재 필요한 부분만 메모리에 적재하도록 할 수 있음.

- `(실제 메모리) physical memory`보다 주소공간이 더 클 수 있음.
- 파일이나 메모리가 둘 또는 그 이상의 프로세스들에 의해 공유되는 것을 가능하게 함.

```
책상에 많은 책을 펴놓고 공부를 할 때 책상에 해당되는 것이 실제 물리 메모리이고 책상에 책을 놔둘 공간이 없어 책을 꽃아놓는 책장이 가상 메모리라고 생각하면 된다.
책상에 펴져있는 책들은 실행 중인 프로세스들이고 책장에 꽂아져있는 책들은 프로그램들이다.
```

## 요구 페이징 (Demand Paging)

> 초기에 필요한 것만 실제 메모리에 적재하고 페이지들이 실행 과정에서 실제로 필요할 때 적재하는 기법. 

- 한번도 접근되지 않는 페이지는 물리 메모리에 적재되지 않게 됨.
- 스와핑 기법과 비슷함. 
- `pager` : 페이지들의 연속. 프로세스 내의 개별 페이지들을 관리함.
- 디스크에서 메모리로 페이지를 적재하는 `swap in`을 수행하는 경우 프로세스가 다시 `swap out`되기 전에 실제로 어떤 페이지들이 사용될 것인지 추측하고 실제로 필요한 페이지들만 메모리로 읽어옴.

프로세스 전체가 아닌 부분 조각 `page`들만 가져오기 때문에 특정 프로세스 내에서 어떤 페이지가 실제 메모리에 적재 되어있는지 아닌지를 구별해야함. 

`page table`의 `valid-invalid bit `를 이용해 판단함. 

**page table**

- 페이지 테이블에는 각각의 page에 맵핑되는 frame과 valid-invalid bit로 구성되어 있음.
- valid-invalid bit를 통해 어떤 페이지가 실제 물리 메모리에 적재되어있는지 표시해주고 만약 실제 물리 메모리에 적재되어있지 않다면 그 페이지가 저장되어있는 디스크 주소를 기록해 나중에 필요할 때 디스크에서 가져올 수 있게 함.

### page fault

>  실제 물리 메모리에 적재되어있지 않는 페이지를 접근하려고 할 때 발생하는 트랩.

현재 접근하려고 하는 페이지 테이블의 valid-invalid bit 항목이 무효로 되어있으면 발생함.

**순수 요구 페이징 (pure demand paging)**

> 어떤 페이지가 필요해지기 전에는 페이지를 적재하지 않는 것

순수 요구 페이징을 사용하면 맨 처음부터 `page fault`가 발생함. 

#### page fault handling (페이지 부재 처리)

![page fault](http://contribute.geeksforgeeks.org/wp-content/uploads/121-1.png)

1. 프로세스에 대한 내부 테이블을 검사해서 그 메모리 참조가 유효(valid)/무효(invalid) 인지를 알아낸다.
2. 만약 무효한 페이지에 대한 참조라면 그 프로세스는 중단된다. 

​     만약 유효한 참조인데 페이지가 아직 메모리에 올라오지 않았다면, 그것을 디스크로부터 가져와야 한다.

3. 빈 공간 즉, 자유 프레임을 찾는다. (예를 들면, 페이지 프레임 리스트에서 하나 가져옴)
4. 디스크에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청한다.
5. 디스크 읽기가 끝나면, 이 페이지가 이제는 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신하며, 

​    프로세스가 유지하고 있는 내부 테이블을 수정한다.

6. 트랩에 의해 중단되었던 명령을 다시 수행한다. 

​     이제 프로세스는 마치 그 페이지가 항상  메모리에 있었던 것처럼 해당 페이지를 접근할 수 있다.



**지역성의 원리 (locality of reference)**

> CPU가 참조하는 주소가 지역에 모여져있다.

한번 읽었던 코드(주소)를 다시 읽을 확률(while, for)이 높기 때문에 `page fault`가 문제가 될 만큼 많이 일어나지 않음.



## 페이지 교체 (Page Replacement)

> 프로세스가 메모리보다 더 큰 용량의 페이지를 적재하려고 할 때 (메모리가 꽉 찼을 때) 페이지 알고리즘을 통해 페이지를 교체하는 것

- 프로그램이 실행되면서 요구 페이지가 늘어나고 메모리가 가득 차서 페이지를 올릴 자리가 없을 때 특정 페이지(`victim page`)와 교체하는 것.
- 해당 페이지가 수정됬는지 아닌지를 확인(modifiy bit or dirty biy)해서 수정됬으면 디스크에도 수정을 해야하므로 수정되지 않은 페이지를 골라 교체함.

**victim page**

 희생자 페이지. 메모리에 할당되어야 하는 페이지에게 자신의 자리를 내어주는 페이지임.

![page replacement](https://meherchilakalapudi.files.wordpress.com/2011/12/75.jpg)

그렇다면 희생자 페이지는 어떤 알고리즘을 통해 고를까?

### FIFO Algorithm

> 할당된지 오래된 페이지를 교체하는 것.

- 오래된 페이지가 얼마나 자주 사용될지도 모르는데 교체하는 것은 무모함.
- 페이지 부재율(page fault)가 높아지고 효율적이지 않음
- 페이지가 교체되어도 바로 부재처리(page fault handling) 되어 다시 메모리에 적재시키며 프로세스가 정상적으로 동작함.

### Optimal Algorithm

> 최적 알고리즘. 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 것.

- 프레임 수가 고정된 경우 가장 낮은 페이지 부재율을 보장함.
- 알고리즘 구현이 어려움

### LRU Alogirithm

> 가장 오랜 기간 사용되지 않은 페이지를 교체하는 것.

- `optimal algorithm`은 미래를 내다보는 것이라면 `least recently used algorithm`은 과거를 보고 미래를 예측한다고 생각하면 됨. (최근에 사용되지 않았으면 나중에도 사용되지 않을 것)
- 실질적으로 사용 가능한 알고리즘

